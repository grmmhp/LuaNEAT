----- THIS CODE IS TO BE PUT BEFORE "return LuaNEAT" ON THE LuaNEAT.lua FILE



------- DEBUG
_TARGET_WORD = "THISISAREALLYREALLYREALLYIMEANVERYREALLYLONGSTRINGOHMYGODWILLITEVOLVE"

_SYMBOLS = {
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
}

local function _RANDOM_GENOTYPE()
  local gen = ""

  while string.len(gen) < string.len(_TARGET_WORD) do
    gen = gen .. _SYMBOLS[LuaNEAT.random(1, #_SYMBOLS)]
  end

  return gen
end

local function _DISTANCE(genome, gen_pos)
  local actual = string.sub(genome, gen_pos, gen_pos)
  local expected = string.sub(_TARGET_WORD, gen_pos, gen_pos)
  local index_actual
  local index_expected

  for i=1, #_SYMBOLS do
    if _SYMBOLS[i] == actual then
      index_actual = i
    end
    if _SYMBOLS[i] == expected then

    end
  end

  return math.abs(index_expected - index_actual)
end

local function _DIFF(c1, c2)
  local i1
  local i2

  for i=1, #_SYMBOLS do
    if _SYMBOLS[i] == c1 then
      i1 = i
    end
    if _SYMBOLS[i] == c2 then
      i2 = i
    end
  end

  return math.min(
    math.abs(i1-i2),
    math.abs(i1 - (26-i2))
  )
end

local function _CALCULATE_FITNESS(genome)
  local word = genome._DEBUG_DNA

  local sum = 0
  for i=1, string.len(_TARGET_WORD) do
    local char = string.sub(word, i, i)

    if char ~= string.sub(_TARGET_WORD, i, i) then
      sum = sum + 1
    end
  end

  if sum==0 then return math.huge end

  return 1/sum
end

local function _ASSIGN_FITNESS_TO_ALL()
  for _, sp in ipairs(_POOL.species) do
    for i, gen in ipairs(sp.genomes) do
      gen.fitness = _CALCULATE_FITNESS(gen)
    end
  end
end

local function _PRINT_ALL()
  for _, sp in ipairs(_POOL.species) do
    print(">>> species #".. _)
    for i, gen in ipairs(sp.genomes) do
      print(gen._DEBUG_DNA, "fitness = ".. gen.fitness)
    end
  end
end

local function _MUTATE(genome)
  local function GET_INDEX(char)
    for i=1, #_SYMBOLS do
      if char == _SYMBOLS[i] then
        return i
      end
    end
  end

  local PERTURB_CHANCE = 0.2--LuaNEAT.parameters.perturbWeight
  local REPLACE_CHANCE = 0.5--LuaNEAT.parameters.replaceWeight
  local STEP_SIZE = 3

  local mutated = ""

  for i=1, string.len(_TARGET_WORD) do
    local char = string.sub(genome._DEBUG_DNA, i, i)
    if LuaNEAT.random() < PERTURB_CHANCE then
      if LuaNEAT.random() < REPLACE_CHANCE then
        local rand = _SYMBOLS[LuaNEAT.random(1, #_SYMBOLS)]
        mutated = mutated .. rand
      else
        new_index = GET_INDEX(char) + (2*LuaNEAT.random(0, 1)-1)*LuaNEAT.random(1, STEP_SIZE)

        if new_index < 1 then new_index = #_SYMBOLS + new_index end
        if new_index > #_SYMBOLS then new_index = new_index - #_SYMBOLS end

        mutated = mutated .. _SYMBOLS[new_index]
      end
    else
      mutated = mutated .. char
    end
  end

  genome._DEBUG_DNA = mutated
end

local function _CROSSOVER_DNA(gen1, gen2)
  local dna = ""

  for i=1,string.len(gen1._DEBUG_DNA) do
    if LuaNEAT.random() < .5 then
      dna = dna .. string.sub(gen1._DEBUG_DNA, i, i)
    else
      dna = dna .. string.sub(gen2._DEBUG_DNA, i, i)
    end
  end

  return dna
end

----------------------------------------------------------------------
--------------------- OVERWRITING NEAT FUNCTIONS ---------------------
Pool.initialize = function(self)
  if self.generation ~= -1 then error("pool has already been initialized", 2) end
  self.innovation_list:initialize(self.inputs, self.outputs, self.noBias)

  for n=1, self.size do
    self.genome_counter = self.genome_counter + 1
    local id = self.genome_counter
    local genome = Genome.minimal(id, self.inputs, self.outputs, self.parameters, self.noBias)
    genome._DEBUG_DNA = _RANDOM_GENOTYPE()

    table.insert(self.nets, genome:buildNeuralNetwork())
    self:speciate(genome)
  end

  self.generation = 1
end

function Genome.sameSpecies(genome1, genome2, parameters)
  local distance = 0

  for i=1,string.len(genome1._DEBUG_DNA) do
    local c1 = string.sub(genome1._DEBUG_DNA, i, i)
    local c2 = string.sub(genome2._DEBUG_DNA, i, i)

    distance = distance + _DIFF(c1, c2)^2
  end

  return math.sqrt(distance) < math.huge--25--parameters.sameSpeciesThreshold
end

function Genome:copy()
  local genome
  local neuron_list = {}
  local link_list = {}

  for n=1,#self.neuron_list do
    table.insert(neuron_list, self.neuron_list[n]:copy())
  end

  for n=1,#self.link_list do
    table.insert(link_list, self.link_list[n]:copy())
  end

  genome = Genome(self.id, neuron_list, link_list)
  genome.species = self.species
  genome.fitness = self.fitness
  genome.number_of_inputs = self.number_of_inputs
  genome.number_of_outputs = self.number_of_outputs
  genome.bias = self.bias

  genome._DEBUG_DNA = self._DEBUG_DNA

  return genome
end

Species.breed = function(self, id, parameters, innovation_list)
  local genome1, genome2, offspring, index

  genome1, index = self:tournamentSelection(parameters.tournamentSize)

  if LuaNEAT.random() < parameters.crossoverRate and #self.genomes > 1 then
    -- swaping genome1 with this species' first genome
    -- it doesn't matter swap then again after crossover
    -- because genomes will be ordered in the culling process.
    self.genomes[1], self.genomes[index] = self.genomes[index], self.genomes[1]

    genome2 = self:tournamentSelection(parameters.tournamentSize, 1)
    offspring = Genome.crossover(genome1, genome2)
    offspring._DEBUG_DNA = _CROSSOVER_DNA(genome1, genome2)
  else
    -- copying genome 1
    offspring = genome1:copy()
  end

  offspring.id = id
  offspring.fitness = 0

  offspring:mutate(parameters, innovation_list)
  _MUTATE(offspring)


  return offspring
end
----------------------------------------------------------------------
----------------------------------------------------------------------

_POOL = LuaNEAT.newPool(100, 1, 1)
_POOL:initialize()

local gen = _POOL.species[1].genomes[1]
print(gen._DEBUG_DNA)
print(_CALCULATE_FITNESS(gen))


for i=1, 1000 do
  _ASSIGN_FITNESS_TO_ALL()
  _PRINT_ALL()

  local done
  for _,net in ipairs(_POOL.nets) do
    if net.genome._DEBUG_DNA == _TARGET_WORD then
      done = true
      break
    end
  end

  if done then print("\nFOUND SOLUTION ON GENERATION ".. _POOL.generation) break end

  print(_POOL:nextGeneration())
end
