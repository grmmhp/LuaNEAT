local neat = require"LuaNEAT"
print(neat.version())

local cartpole = {}

local cart_width = 50
local cart_height = 25
local cart_x = 650/2
local cart_y = 650/2 - cart_height/2
local cart_mass = 1
local force = 1000

local ball_density = 100--5--.5
local radius = 5

local length = 100

local offset = math.rad(15)--love.math.random(30, 60)
local initial_angle --= ---math.pi/2 + (2*love.math.random(1)-1)*math.rad(offset)
local last_angle -- used to compute the angular velocity

if love.math.random() > .5 then
  initial_angle = -math.pi/2 + offset
else
  initial_angle = -math.pi/2 - offset
end

local gravity = 9.81
local meter = 64

local world
local objects = {}

local mode="cart"

-- neat
local pool = neat.newPool(300, 4, 1, true)--4, 2)

pool.parameters.mutation_rates.loopedLink = 0
pool.parameters.mutation_rates.addLink = 0.988
pool.parameters.mutation_rates.addNode = 0.085
pool.parameters.mutation_rates.perturbWeight = 0.460
pool.parameters.mutation_rates.replaceWeight = 0.0245
pool.parameters.mutation_rates.weightStep = 0.825
pool.parameters.mutation_rates.enableDisable = 0.0138

pool.parameters.excessGenesCoefficient   = 1
pool.parameters.disjointGenesCoefficient = 1
pool.parameters.matchingGenesCoefficient = 0.4
pool.parameters.sameSpeciesThreshold     = 1


pool:initialize()
local networks = pool:getNeuralNetworks()
local evaluating = 1
local time_surv = 0
local max_time = math.huge--10*60 -- 10 minutes of max simulation time

neat.save(pool, "test.txt")

--neat_pool.parameters.initialWeightRange = 30



love.window.setMode(650, 650)

local function map(value, x0, x1, y1, y2)
  return (value-x0)/(x1-x0)*(y2-y1) + y1
end

local function clamp(value, x0, x1, y1, y2)
  value = math.min(value, x1)
  value = math.max(value, x0)

  return map(value, x0, x1, y1, y2)
end

local function reset_sim()
  --offset = love.math.random(-5, 5)
  --initial_angle = -math.pi/2 + (2*love.math.random(1)-1)*math.rad(offset)
  if love.math.random() > .5 then
    initial_angle = -math.pi/2 + offset
  else
    initial_angle = -math.pi/2 - offset
  end

  objects.cart.body:setPosition(cart_x, cart_y)
  objects.cart.body:setLinearVelocity(0, 0) --we must set the velocity to zero to prevent a potentially large velocity generated by the change in position

  objects.ball.body:setPosition(cart_x + length*math.cos(initial_angle), cart_y + length*math.sin(initial_angle))
  objects.ball.body:setLinearVelocity(0, 0)



  if love.math.random() > .5 then
    objects.cart.body:setLinearVelocity(100, 0)
  else
    objects.cart.body:setLinearVelocity(-100, 0)
  end
end

function cartpole.load()
  love.math.setRandomSeed(os.time())

  love.physics.setMeter(meter)
  world = love.physics.newWorld(0, gravity*meter, true)

  objects.ground = {}
  objects.ground.body = love.physics.newBody(world, 650/2, 650-325/2) --remember, the shape (the rectangle we create next) anchors to the body from its center, so we have to move it to (650/2, 650-50/2)
  objects.ground.shape = love.physics.newRectangleShape(650, 325) --make a rectangle with a width of 650 and a height of 50
  objects.ground.fixture = love.physics.newFixture(objects.ground.body, objects.ground.shape) --attach shape to body

  objects.cart = {}
  objects.cart.body = love.physics.newBody(world, cart_x, cart_y, "dynamic")
  objects.cart.shape = love.physics.newRectangleShape(0, 0, cart_width, cart_height)
  objects.cart.fixture = love.physics.newFixture(objects.cart.body, objects.cart.shape, cart_mass/((cart_width/meter)*(cart_height/meter))) -- A higher density gives it more mass.

  --let's create a ball
  local ball_x = cart_x + length*math.cos(initial_angle)
  local ball_y = cart_y + length*math.sin(initial_angle)
  objects.ball = {}
  objects.ball.body = love.physics.newBody(world, ball_x, ball_y, "dynamic") --place the body in the center of the world and make it dynamic, so it can move around
  objects.ball.shape = love.physics.newCircleShape(radius) --the ball's shape has a radius of 20
  objects.ball.fixture = love.physics.newFixture(objects.ball.body, objects.ball.shape, ball_density) -- Attach fixture to body and give it a density of 1.
  objects.ball.fixture:setRestitution(0.9) --let the ball bounce

  --love.physics.newDistanceJoint( body1, body2, x1, y1, x2, y2, collideConnected )
  love.physics.newDistanceJoint(objects.cart.body, objects.ball.body, cart_x, cart_y, ball_x, ball_y)
end

function cartpole.keypressed(key)
  if key=="e" then
    if mode=="cart" then
      mode="stats"
    elseif mode=="stats" then
      mode="cart"
    end
  end
end

function cartpole.update(dt)
  local cx, cy = objects.cart.body:getX(), objects.cart.body:getY()
  local bx, by = objects.ball.body:getX(), objects.ball.body:getY()
  local ang = math.atan2((by-cy), (bx-cx))

  world:update(dt)

  cx, cy = objects.cart.body:getX(), objects.cart.body:getY()
  bx, by = objects.ball.body:getX(), objects.ball.body:getY()
  cv = objects.cart.body:getLinearVelocity()
  ang = math.atan2((cy-by), (bx-cx))
  if not last_angle then last_angle = ang end
  local angv = (ang-last_angle)/dt

  local n_cx = clamp(cx, 0, 600, -1, 1)
  local n_cv = clamp(cv, -300, 300, -1, 1)
  local n_ang = clamp(ang, 0, math.pi, -1, 1)
  local n_angv = map(math.deg(angv), -180, 180, 0, 1)

  local net = networks[evaluating]
  --local outputs = net:forward(n_cx, n_cv, n_ang, n_angv) -- cart pos, cart vel, ang, ang vel
  local outputs = net:forward(n_cx, n_cv, n_ang, n_angv)


  last_angle = ang

  --[[if outputs[2] > outputs[1] then
    objects.cart.body:applyForce(force, 0)
  else
    objects.cart.body:applyForce(-force, 0)
  end]]
  objects.cart.body:applyForce(outputs[1]*force, 0)
  --objects.cart.body:applyForce(outputs[2]*force, 0)


  time_surv = time_surv + dt


  if cx < 50 or cx > 600
  or ang < 0 or ang > math.pi
  or time_surv > max_time then
    net:setFitness(time_surv)
    time_surv = 0
    reset_sim()

    evaluating = evaluating + 1
    if evaluating > #networks then
      print(pool:nextGeneration())
      evaluating = 1

      networks = pool:getNeuralNetworks()
    end
  end
end

function cartpole.draw()
  if mode=="cart" then
    love.graphics.setBackgroundColor(1,248/255,182/255)

    -- drawing the ground
    love.graphics.setColor(32/255,101/255,95/255)
    love.graphics.polygon("fill", objects.ground.body:getWorldPoints(objects.ground.shape:getPoints()))

    -- drawing the cart
    love.graphics.setColor(248/255,170/255,39/255) -- set the drawing color to grey for the blocks
    love.graphics.polygon("fill", objects.cart.body:getWorldPoints(objects.cart.shape:getPoints()))

    love.graphics.setLineWidth(3)
    love.graphics.line(objects.cart.body:getX(), objects.cart.body:getY(), objects.ball.body:getX(), objects.ball.body:getY())

    love.graphics.setColor(250/255,197/255,91/255)
    love.graphics.circle("fill", objects.ball.body:getX(), objects.ball.body:getY(), objects.ball.shape:getRadius())

    -- stats
    local cx, cy = objects.cart.body:getX(), objects.cart.body:getY()
    local bx, by = objects.ball.body:getX(), objects.ball.body:getY()

    local cv = objects.cart.body:getLinearVelocity()
    local ang = math.atan2((cy-by), (bx-cx))
    love.graphics.setColor(0,0,0)
    love.graphics.print(
      "Generation ".. pool:getGeneration() ..
      "\nCandidate #".. evaluating ..
      "\nX Position " .. cx ..
      "\nVelocity: ".. cv ..
      "\nPole angle: ".. math.deg(ang) ..
      "\nGenome ID: ".. networks[evaluating]:getGenomeID() ..
      "\nSpecies ID: ".. networks[evaluating]:getSpeciesID() ..
      string.format("\nFitness: %.2f", time_surv) ..
      "\n" .. pool:getSpeciesAmount() .. " total species"..
      "\nTop fitness: ".. pool.top_fitness,
      10, 10
    )

    love.graphics.setLineWidth(2)
    local genome = networks[evaluating].genome--pool.last_best--pool.species[1].genomes[1]
    --genome = pool.species[s].genomes[g]
    if genome then genome:draw(300, 250, 300, 650-250-20) end
  elseif mode=="stats" then
    love.graphics.setBackgroundColor(1,1,1)

    love.graphics.setColor(0,0,0,1)

    local margin=50
    love.graphics.rectangle("line", margin, margin, 650-margin*2, 650-margin*2)

    local points = pool.statistics:getTopFitnessPoints()
    local top_fit=-math.huge
    local min_fit=math.huge
    for n=1,#points do
      if points[n]>top_fit then
        top_fit = points[n]
      end
      if points[n]<min_fit then
        min_fit = points[n]
      end
    end

    local points_xy = {}
    for n=1,#points do
      local x = map(n, 1, #points, margin, 650-margin)
      local y = map(points[n], min_fit, top_fit, 650-margin, margin)
      table.insert(points_xy, x)
      table.insert(points_xy, y)
    end
    love.graphics.setColor(0,.3,.8,1)
    if #points>1 then
      love.graphics.line(points_xy)
    end
    for n=1,#points do
      local x = points_xy[2*n-1]
      local y = points_xy[2*n]
      love.graphics.circle("fill", x, y, 2.5)
    end
    love.graphics.setColor(0,0,0,1)
    love.graphics.print("max fitness: ".. top_fit .. "\nmin fitness: ".. min_fit, 10, 10)
  end
end

return cartpole
